package main

import (
	"fmt"
	"math"
	"os"
	"sort"
	"strconv"
	"time"
)

// @formatter:off

// Entry point of method/algorithm  
func xRootOfy(fyneFunc func(string), radical_index int, done chan bool) { // calculates either square or cube root of any integer

	usingBigFloats = false

	var index = 0 // counter used in the for loop in this func :: is also passed to the principal func readTheTableOfPP

	TimeOfStartFromTop := time.Now()

	radical_index, workPiece := setStateOfSquareOrCubeRoot(fyneFunc, radical_index, done) // Obtain workPiece, and set/adjust a global precision val based on the workPiece : the number to solve for.

	buildTableOfPerfectProducts(radical_index) // 800,000 entries, 400,000 pairs

	// The following section consists of the principal for loop with a conditional break ------------------------------------------------------------------
	// -----------------------------------------------------------------------------------------------------------------------------------------------------

	startBeforeCall := time.Now()

	// read the table built half a dozen lines prior; index will be a sequence of even numbers 
	for index < 400000 { // the table has 825,000 entries, > 410,000 pairs; so index increments by 2 at the bottom of this loop (200,000 iterations)

		// report on progress of results 
		readTheTableOfPP(index, startBeforeCall, radical_index, workPiece) // pass-in an index to the table: 400,000 indexes corresponding to the number of pairs of entries

		handlePerfectSquaresAndCubes(TimeOfStartFromTop, radical_index, workPiece) // handle the rare case of a perfect square or cube (report to a file, that is all that is done here)

		if diffOfLarger == 0 || diffOfSmaller == 0 { // Then, it was a perfect square or cube; so, we need to ...
			break // ... out of the for loop because we are done : the workpiece was either a perfect square or a perfect cube
		}

		if index == 80000 {
			fmt.Println("\n80,000 ... still working ...")
		}
		if index == 160000 {
			fmt.Println("\n160,000 ... still working ...")
		}
		if index == 240000 {
			fmt.Println("\n240,000 ... still working ...")
		}
		if index == 320000 {
			fmt.Println("\n320,000 ... still working, almost there ...\n")
		}

		index = index + 2 // increment the index and read the table again
	} // end of for loop // the above break statement is NOT the only way to exit this for loop, it also terminates after 200,000 iterations of index

	// ::: Show the final result 
	// All of the remaining sections are conditional for workpiece NOT being a perfect square or cube
	if perfectResult2 == 0 && perfectResult3 == 0 { // Then, it was NOT a perfect square or cube, so handle that case
		// the remaining sections are only reached after having exited the primary for loop above via a break statement or an exaustive reading of the table ------------
		// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
		// calculate elapsed time
		t_s2 := time.Now()
		elapsed_s2 := t_s2.Sub(TimeOfStartFromTop)

		// the following sections log the final results to a text file (and also does one conditional Printf) -------------------------------------------------
		// -----------------------------------------------------------------------------------------------------------------------------------------------------
		fileHandle, err31 := os.OpenFile("dataLog-From_calculate-pi-and-friends.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600) // append to file
		check(err31)                                                                                                             // ... gets a file handle to dataLog-From_calculate-pi-and-friends.txt
		defer fileHandle.Close()                                                                                                 // It’s idiomatic to defer a Close immediately after opening a file.

		Hostname, _ := os.Hostname()
		_, err30 := fmt.Fprintf(fileHandle, "\n  -- %d root of %d by a ratio of perfect Products -- selection #%d on %s \n", radical_index, workPiece, Hostname)
		check(err30)

		current_time := time.Now()
		_, err36 := fmt.Fprint(fileHandle, "was run on: ", current_time.Format(time.ANSIC), "\n")
		check(err36)

		// index = index
		_, err35 := fmt.Fprintf(fileHandle, "%d was total Iterations \n", index)
		check(err35)

		// Sort the slice sortedResults by its pdiff field :
		// -----------------------------------------------------------------------------------------------------------
		sort.Slice(sortedResults, func(i, j int) bool { return sortedResults[i].pdiff < sortedResults[j].pdiff })

		/*
		   // print the sorted slice twice; once for each field
		       fmt.Println("Here are the results:")
		       resultCount := 1
		       for _, result := range sortedResults {
		           fmt.Printf("%d, %0.16f \n", resultCount, result.result)
		           resultCount++
		       }
		       fmt.Println("And here are the p-diffs:")
		       pdiffCount := 1
		       for _, result := range sortedResults {
		           fmt.Printf("%d, %0.16f \n", pdiffCount, result.pdiff)
		           pdiffCount++
		       }
		*/

		// display and print the best-fitting result based solely on the lowest pdiff :
		// -----------------------------------------------------------------------------

		// display the best fitting result :
		if radical_index == 2 {
			fmt.Printf("%0.9f, is the best approximation for the Square Root of %d \n", sortedResults[0].result, workPiece)
		}
		if radical_index == 3 {
			fmt.Printf("%0.9f, is the best approximation for the  Cube  Root of %d \n", sortedResults[0].result, workPiece)
		}

		// Fprint/log the best fitting result :
		if radical_index == 2 {
			_, err48 := fmt.Fprintf(fileHandle, "%0.9f, is the best approximation for the Square Root of %d \n", sortedResults[0].result, workPiece)
			check(err48)
		}
		if radical_index == 3 {
			_, err49 := fmt.Fprintf(fileHandle, "%0.9f, is the best approximation for the  Cube  Root of %d \n", sortedResults[0].result, workPiece)
			check(err49)
		}

		TotalRun := elapsed_s2.String() // cast time durations to a String type for Fprintf "formatted print"
		_, err57 := fmt.Fprintf(fileHandle, "Total run was %s \n ", TotalRun)
		check(err57)

		fileHandle.Close()

		/*
		   // all this crap with these 3 arrays was cute, but it does not sort as a record with fields, so it is not what I want
		               array_len := len(List_of_2_results_case18)
		               _ , err8 := fmt.Fprintf(fileHandle, "%d was len of array \n", array_len)
		                   check(err8)
		               if array_len > 0 {
		                   index := 0
		                   for array_len > 0 {
		                       result_from_array := List_of_2_results_case18[index]
		                       array_len--
		                        _ , err9 := fmt.Fprintf(fileHandle, "%0.16f with a diff of %d, percent diff of %0.4f percent\n",
		                           result_from_array, corresponding_diffs[index], diffs_as_percent[index]*100000)
		                               check(err9)
		                       index++
		                   }
		               }
		               List_of_2_results_case18 = nil
		               corresponding_diffs = nil
		*/
	}
	// we need to end here ::: ???
	return // is this the way to end it ??
}

// report to a file the rare case of having found a perfect square 
func handlePerfectSquaresAndCubes(TimeOfStartFromTop time.Time, radical_index, workPiece int) {
	// the next sub-section detects, traps, and reports the detection of either a perfect square of a perfect cube ------------------
	// ... it also is responsible for causing the algorithm to terminate via a break if workpiece was a perfect square or cube
	// -------------------------------------------------------------------------------------------------------------------------------
	if diffOfLarger == 0 || diffOfSmaller == 0 { // Then, it was a perfect square or cube

		t_s1 := time.Now()
		elapsed_s1 := t_s1.Sub(TimeOfStartFromTop) // need to pass this to the func we are planning to build ?? NO, "two" "perfect".

		fileNameToWriteTo := "dataLog-From_calculate-pi-and-friends.txt" // would have been used/needed if we emplement a func for this.

		// fileHandle, err1 := os.OpenFile("dataLog-From_calculate-pi-and-friends.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
		fileHandle, err1 := os.OpenFile(fileNameToWriteTo, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
		check(err1)              // ... gets a file handle to dataLog-From_calculate-pi-and-friends.txt
		defer fileHandle.Close() // It’s idiomatic to defer a Close immediately after opening a file.

		Hostname, _ := os.Hostname()
		_, err0 := fmt.Fprintf(fileHandle, "\n  -- %d root of %d by a ratio of PerfectProducts -- selection #%d on %s \n",
			radical_index, workPiece, Hostname)
		check(err0)

		current_time := time.Now()
		_, err6 := fmt.Fprint(fileHandle, "was run on: ", current_time.Format(time.ANSIC), "\n")
		check(err6)

		TotalRun := elapsed_s1.String() // cast time durations to a String type for Fprintf "formatted print"
		_, err7 := fmt.Fprintf(fileHandle, "Total run was %s \n ", TotalRun)
		check(err7)

		if radical_index == 2 {
			_, err8 := fmt.Fprintf(fileHandle, "the %d root of %d is %0.2f \n", radical_index, workPiece, perfectResult2)
			check(err8)
		}
		if radical_index == 3 {
			_, err38 := fmt.Fprintf(fileHandle, "the %d root of %d is %0.2f \n", radical_index, workPiece, perfectResult3)
			check(err38)
		}

		fileHandle.Close()

		// break // break out of the for loop because we are done : the workpiece was either a perfect square or a perfect cube

	} // end of if :: if it was a perfect square or cube
	// -------------------------------------------------------------  CASE 18: ------------------------------------------------------------------

}

func readTheTableOfPP(index int, startBeforeCall time.Time, radical_index, workPiece int) { // this gets called 400,000 times.

	// The first time it is called index is 0

	// read it ...
	smallerPerfectProductOnce := Table_of_perfect_Products[index]
	// ... and save it locally, do this just-once per func call. // ... index may be 0 up to 380,000
	RootOfsmallerPerfectProductOnce := Table_of_perfect_Products[index+1]
	// ^^^ also read the root wich corresponds

	iter := 0
	for iter < 410000 { // 410,000 loops. Why do we need so many?, Because we need to read through 825,000 table entries pairs
		iter++ //  ... iters are therefore half the number of pairs. There are actually 1,600,000 items, but who's counting?
		index = index + 2
		largerPerfectProduct := Table_of_perfect_Products[index]
		// to approximate the root of an imperfect square x we will need a ratio of two perfect squares wich is about equal to x
		// ...we need to find two perfect squares such that one is about x times larger than the other
		// get next perfect square from table for testing to see if it is more than x * bigger than smallerPerfectProductOnce

		if largerPerfectProduct > smallerPerfectProductOnce*workPiece {
			// if largerPerfectProduct is a candidate based on it being just-a-bit larger than workPiece* the smaller PP deal with that, else loop to the next potential

			ProspectiveHitOnLargeSide := largerPerfectProduct                     // make a copy under a more suitable name :)
			rootOfProspectiveHitOnLargeSide := Table_of_perfect_Products[index+1] // the current value of index plus one holds the root of largerPerfectSquare hence the root of ProspectiveHitOnLargeSide

			ProspectiveHitOnSmallerSide := Table_of_perfect_Products[index-2]
			// save that smaller one too //                               ^^ 2 now instead of 1 because we have added roots to the slice
			rootOfProspectiveHitOnSmallerSide := Table_of_perfect_Products[index-1]

			diffOfLarger = ProspectiveHitOnLargeSide - workPiece*smallerPerfectProductOnce
			// diffOfSmaller = -(ProspectiveHitOnSmallerSide - workPiece*smallerPerfectProductOnce) // this was dumb ??
			diffOfSmaller = workPiece*smallerPerfectProductOnce - ProspectiveHitOnSmallerSide

			// detect perfect squares and set global vars to their roots -----------------------------------------------
			if diffOfLarger == 0 {
				fmt.Println(colorCyan, "\n The", radical_index, "root of", workPiece, "is", colorGreen,
					float64(rootOfProspectiveHitOnLargeSide)/float64(RootOfsmallerPerfectProductOnce), colorReset, "\n")

				perfectResult2 = (math.Sqrt(float64(workPiece))) // these global values are used later to Fprint to a log file
				perfectResult3 = math.Cbrt(float64(workPiece))
				break // out of the for loop because the workPiece is itself a perfect square
			}
			if diffOfSmaller == 0 {
				fmt.Println(colorCyan, "\n The", radical_index, "root of", workPiece, "is", colorGreen,
					float64(rootOfProspectiveHitOnSmallerSide)/float64(RootOfsmallerPerfectProductOnce), colorReset, "\n")

				perfectResult2 = (math.Sqrt(float64(workPiece))) // these global values are used later to Fprint to a log file
				perfectResult3 = math.Cbrt(float64(workPiece))
				break // out of the for loop because the workPiece is itself a perfect square
			}
			// ---------------------------------------------------------------------------------------------------------
			// we are in case 18:

			// larger side section: ----------------------------------------------------------------------------------------------------------------------------------------
			// --------------------------------------------------------------------------------------------------------------------------------------------------------------

			// Progress reporting
			if diffOfLarger < precisionOfRoot { // report the prospects, their differences, and the calculated result for the Sqrt or Cbrt
				fmt.Println("small PP is", colorCyan, smallerPerfectProductOnce, colorReset, "and, slightly on the higher side of", workPiece,
					"* that we found a PP of", colorCyan, ProspectiveHitOnLargeSide, colorReset, "a difference of", diffOfLarger)

				fmt.Println("the ", radical_index, " root of ", workPiece, " is calculated as ", colorGreen,
					float64(rootOfProspectiveHitOnLargeSide)/float64(RootOfsmallerPerfectProductOnce), colorReset)

				fmt.Printf("with pdiff of %0.4f \n", (float64(diffOfLarger)/float64(ProspectiveHitOnLargeSide))*100000)

				// save the result to an accumulator array so we can Fprint all such hits at the very end
				// List_of_2_results_case18 = append(List_of_2_results_case18, float64(rootOfProspectiveHitOnLargeSide) / float64(RootOfsmallerPerfectProductOnce) )
				// corresponding_diffs = append(corresponding_diffs, diffOfLarger)
				// diffs_as_percent = append(diffs_as_percent, float64(diffOfLarger)/float64(ProspectiveHitOnLargeSide))

				// in the next five lines we load (append) a record into/to the file (array) of Results
				Result1 := Results{
					result: float64(rootOfProspectiveHitOnLargeSide) / float64(RootOfsmallerPerfectProductOnce),
					pdiff:  float64(diffOfLarger) / float64(ProspectiveHitOnLargeSide),
				}
				sortedResults = append(sortedResults, Result1)

				t2 := time.Now()
				elapsed2 := t2.Sub(startBeforeCall)
				// if needed, notify the user that we are still working
				Tim_win = 0.178
				if radical_index == 3 {
					if workPiece > 13 {
						Tim_win = 0.0012
					} else {
						Tim_win = 0.003
					}
				}
				if elapsed2.Seconds() > Tim_win {
					fmt.Println(elapsed2.Seconds(), "Seconds have elapsed ... working ...\n")
				}
			}
			// ---------------------------------------------------------------------------------------------------------------------------------------------------------------

			// smaller side section: ----------------------------------------------------------------------------------------------------------------------------------------
			// ---------------------------------------------------------------------------------------------------------------------------------------------------------------
			if diffOfSmaller < precisionOfRoot { // report the prospects, their differences, and the calculated result for the Sqrt or Cbrt
				fmt.Println("small PP is", colorCyan, smallerPerfectProductOnce, colorReset, "and, slightly on the lesser side of", workPiece,
					"* that we found a PP of", colorCyan, ProspectiveHitOnSmallerSide, colorReset, "a difference of", diffOfSmaller)

				fmt.Println("the ", radical_index, " root of ", workPiece, " is calculated as ", colorGreen,
					float64(rootOfProspectiveHitOnSmallerSide)/float64(RootOfsmallerPerfectProductOnce), colorReset)

				fmt.Printf("with pdiff of %0.4f \n", (float64(diffOfSmaller)/float64(ProspectiveHitOnSmallerSide))*100000)

				// save the result to three accumulator arrays so we can Fprint all such hits, diffs, and p-diffs, at the very end of run
				// List_of_2_results_case18 = append(List_of_2_results_case18, float64(rootOfProspectiveHitOnSmallerSide) / float64(RootOfsmallerPerfectProductOnce) )
				// corresponding_diffs = append(corresponding_diffs, diffOfSmaller)
				// diffs_as_percent = append(diffs_as_percent, float64(diffOfSmaller)/float64(ProspectiveHitOnSmallerSide))
				// ***** ^^^^ ****** the preceeding was replaced with the following five lines *******************************************

				// in the next five lines we load (append) a record into/to the file (array) of Results
				Result1 := Results{
					result: float64(rootOfProspectiveHitOnSmallerSide) / float64(RootOfsmallerPerfectProductOnce),
					pdiff:  float64(diffOfSmaller) / float64(ProspectiveHitOnSmallerSide),
				}
				sortedResults = append(sortedResults, Result1)

				t2 := time.Now()
				elapsed2 := t2.Sub(startBeforeCall)
				// if needed, notify the user that we are still working
				Tim_win = 0.178
				if radical_index == 3 {
					if workPiece > 13 {
						Tim_win = 0.0012
					} else {
						Tim_win = 0.003
					}
				}
				if elapsed2.Seconds() > Tim_win {
					fmt.Println(elapsed2.Seconds(), "Seconds have elapsed ... working ...\n")
				}
			} // end of if
			// -------------  we are in case 18:   we are in case 18:   we are in case 18:   we are in case 18:   we are in case 18: ----------------

			break // each time we find a prospect we break out of the for loop --- if we found any prospects using the current index value we break

		} // end of if :: if largerPerfectProduct > smallerPerfectProductOnce*workPiece  //  we only handle reads that were big enough to be prospects
	} // this is the end of the aforementioned for loop that we break out of each time we have found a prospect and handled it
} // the end of the readTheTableOfPP func that gets called 200,000 times

// obtain workPiece and set precision for special cases 
func setStateOfSquareOrCubeRoot(fyneFunc func(string), radical_index int, done chan bool) (int, int) { // ::: - -
	// obtain work piece 
	var workPiece int
	var promptForWorkPieceInput func() // this var is outside the scope of the literal/anonymous "func() {" that we have on the next line. 
	promptForWorkPieceInput = func() { // we could have written it all on one line as var promptForWorkPieceInput = func prompt() { ... }  // note the inclusion of "prompt()" here. 
		showCustomEntryDialog2( // ... in which case, the recursive calls would then be prompt() instead of promptForWorkPieceInput()
			// ^ ^ ^ signature: (title, message string, callback func(string)) {  // and those 3 arguments appear straight away: 
			"Enter the work piece",    // title string
			"Input one whole integer", // message string
			func(input string) { // a callback func that takes one string "input" 
				if input == "" {
					// if input is empty it means the user clicked ok without typing a number as the workPiece; in which case we should re-prompt for the workPiece only 
					promptForWorkPieceInput() // ::: Re-prompt
				}
				if input != "" { // User provided some input; so we will convert the string to an int
					inputNowInt, err := strconv.Atoi(input)
					if err != nil { // if there is an error during conversion we should 
						updateOutput2("\nInput error: Please enter a whole integer\n")
						promptForWorkPieceInput() // ::: Re-prompt
					}
					// at this point we know that the user's input has been verified and has become an integer, locally known as inputNowInt
					workPiece = inputNowInt // copy inputNowInt to a variable with external scope 
								fmt.Printf("\nin else if or of workPiece getter, val is:%d, radical_index: %d\n", inputNowInt, radical_index)
								fmt.Printf("Input: %d\n", inputNowInt)
					// currentWorkPiece := &workPiece // ???
					// At this point, nothing should cause the UI to put up another dialog to request input of the workPiece 

					// ::: Proceed with calculation
					// Runs the calculation in a separate goroutine to avoid blocking the UI thread; and ensures cleanup happens even if the calculation is aborted or fails
					go func(done chan bool) { // a handle to the 'done' chan is passed to xRootOfy who can then use that chan to either send or receive using the 'done' chan (actually the currentDone chan) 
							defer func() { // This closure is "deferred" until the surrounding go func completes, regardless of whether that goroutine finishes normally or panics
								calculating = false // These sorts of deferred statements are termed "clean-up" 
								updateOutput2("Calculation definitely finished prior to this message; it may have run its normal course or it may have been aborted\n")
							}() // the empty () makes this deferred func into a call, rather than just a simple definition 
						xRootOfy(updateOutput2, radical_index, done) // xRootOfy is passed the 'done' var, which was furnished from the (currentDone) chan
							calculating = false // Termed post-calculation clean-up (Grok's words) 
							for _, btn := range buttons2 {
								btn.Enable()
							}
					}(currentDone) // this triggers immediate execution of the go func; combining definition and execution in one statement : currentDone is presumably a variable of type chan bool
					// done is local name - currentDone is the actual channel from the outer scope - (currentDone) bridges the outer scope’s variable to the inner function’s parameter.

				} else { // the Dialog has been canceled by the user having clicked ok without typing a number (or invalid input)
					updateOutput2("Roots canceled because of empty input field; all buttons are now available, please make another selection")
					for _, btn := range buttons2 {
						btn.Enable()
					}
					calculating = false // signifying that the UI is no longer servicing this process 
				}
			},
		)
	}

	/*
	   if workPiece != 0 {
	       // do not ask for workPiece (again) -- and yet it does ??
	   } else {
	       promptForWorkPieceInput() ::: but I need this ?
	   }
	*/
	// promptForWorkPieceInput()


	// set precision for certain known special cases/instances of workPiece values 
	if radical_index == 3 { // if doing a cube root special tolerances are set here for certain problem values, i.e., 2, 11, 17, 3, 4, or 14
		if workPiece > 4 {
			precisionOfRoot = 1700
			fmt.Println("\n Default precision is 1700 \n")
		}
		if workPiece == 2 || workPiece == 11 || workPiece == 17 {
			precisionOfRoot = 600
			fmt.Println("\n resetting precision to 600 \n")
		}
		if workPiece == 3 || workPiece == 4 || workPiece == 14 {
			precisionOfRoot = 900
			fmt.Println("\n resetting precision to 900 \n")
		}
	}
	if radical_index == 2 { // if doing a square root we just use a tolerance of 4 for all workpieces.
		precisionOfRoot = 4
	}
	return radical_index, workPiece
}

// Build a table of 825,000 pairs of PPs with their roots, does either squares or cubes:

func buildTableOfPerfectProducts(radical_index int) {

	var PerfectProduct int
	Table_of_perfect_Products = nil // this fixed my bug
	root := 10
	iter := 0
	for iter < 825000 { // a table of 825,000 pairs: PPs with their roots. That ought to do it !!
		iter++
		root++
		if radical_index == 3 { // build an array of perfect cubes
			PerfectProduct = root * root * root
		}
		if radical_index == 2 { // build an array of perfect squares
			PerfectProduct = root * root
		}
		Table_of_perfect_Products = append(Table_of_perfect_Products, PerfectProduct)
		Table_of_perfect_Products = append(Table_of_perfect_Products, root) // the root of the prior PP
	}
	// written entirely by Richard Woolley
} // end of xRootOfy()

package main

import (
	"fmt"
	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
	"image/color"
	"strconv"
)

// @formatter:off

var (
	bgsc2 = canvas.NewRectangle(color.NRGBA{R: 130, G: 160, B: 250, A: 140}) // Light blue // was: 130, 160, 250, 160 ::: - -
	bgwc2 = canvas.NewRectangle(color.NRGBA{R: 110, G: 255, B: 160, A: 150}) // Light green ::: - -
	
	outputLabel2 = widget.NewLabel("Classic Pi calculators, make a selection") // ::: - -
	scrollContainer2 = container.NewScroll(outputLabel2) // ::: - -
	window2 = myApp.NewWindow("Rick's Pi calculation Demo, set #2") // ::: - -
)

// Three Additional Windows: 
// ::: ------------------------------------------------------------------------------------------------------------------------------------------------------------
func createWindow2(myApp fyne.App) fyne.Window {
	window2.Resize(fyne.NewSize(1900, 1600))
	outputLabel2.Wrapping = fyne.TextWrapWord
	scrollContainer2.SetMinSize(fyne.NewSize(1900, 1000))

	coloredScroll2 := container.NewMax(bgsc2, scrollContainer2) // Light blue-ish scroll bg

	// ::: Get single input dialog < - - - - - - - - - - - - - - - - - - - - - - - - < -
	getSingleInput2 := func(title, prompt, defaultValue string, callback func(string, bool)) {
		confirmed := false // Track if OK was clicked
		d := dialog.NewEntryDialog(title, prompt, func(value string) {
			confirmed = true
			callback(value, true)
		}, window2)
		d.SetText(defaultValue)
		d.SetOnClosed(func() {
			if !confirmed { // Only trigger cancel if OK wasn’t clicked
				callback("", false)
			}
		})
		d.Show()
	}
	// ::: Dual input dialog < - - - - - - - - - - - - - - - - - - - - - - - - < -
	getDualInput2 := func(title, prompt1, prompt2, default1, default2 string, callback func(string, string, bool)) {
		calculating = true
		for _, btn := range buttons2 {
			btn.Disable()
		}
		entry1 := widget.NewEntry()
		entry1.SetText(default1)
		entry2 := widget.NewEntry()
		entry2.SetText(default2)
		submitButton := widget.NewButton("Run with those values",
			func() {
				callback(entry1.Text, entry2.Text, true)
				dialog.NewInformation("Submitted", "Values submitted", window2).Hide() // Hack to close dialog
				calculating = true
				for _, btn := range buttons2 {
					btn.Disable()
				}
			})
		form := container.NewVBox(
			widget.NewLabel(prompt1), entry1,
			widget.NewLabel(prompt2), entry2,
			// container.NewHBox(submitButton, cancelButton), // ?? still get Close button ? need no cancelButton ??
			container.NewHBox(submitButton),
		)
		d := dialog.NewCustom(title, "Dismiss dialogBox", form, window2)

		d.Resize(fyne.NewSize(400, 300))
		d.Show()
	}

	// ::: Buttons2
	
	done := make(chan bool) // local, kill channel for all goroutines that are listening: ::: not entirely sure of this one ???

	RootsBtn2 := NewColoredButton(
		// signature of ^ ^ ^ ^ (label string, backgroundColor color.Color, tapped func()) *ColoredButton { // 
		"Roots\n" +
			"2 or 3\n" +
			"any integer\n" +
			"                   -*-*- Rick's own-favorite method -*-*-     ", // first argument, one string
		color.RGBA{255, 255, 100, 235},                         // a color.Color argument 
		func() {                                                            // a func() { 
			var radical_index int                                               // finally it "returns" *ColoredButton which is thereby named RootsBtn2
			if calculating {                                                // ... and yet, no actions are called for by having done all of this!!
				return                                  // several levels of nested functions of various morphs. All of it subsumed by a mere label: RootsBtn2
			}                                          // later we will stuff RootsBtn2 into a "content2 := container.NewVBox( "  -- labels on top of labels
			calculating = true
			for _, btn := range buttons2 {
				btn.Disable()
			}
			for _, btn := range rootBut2 {
				calculating = true
				btn.Enable()
			}
			currentDone = make(chan bool) // New channel per run
			updateOutput2("\nRunning Roots ...\n\n")

			// Define a recursive function to handle input validation
			var promptFor2or3Input func() // this var is outside the scope of the literal/anonymous "func() {" that we have on the next line. 
			promptFor2or3Input = func() { // we could have written it all on one line as var promptFor2or3Input = func prompt() { ... }  // note the inclusion of "prompt()" here. 
				showCustomEntryDialog2(   // ... in which case, the recursive calls would then be prompt() instead of promptFor2or3Input()
					// ^ ^ ^ signature: (title, message string, callback func(string)) {  // and those 3 arguments appear straight away: 
					"Input 2 for square root, 3 for cube root", // title string
					"Enter 2 or 3 only",                   // message string
					func(input string) {                           // a callback func that takes one string "input" 
						if input != "" { // User provided some input
							val, err := strconv.Atoi(input)
							if err != nil {
								updateOutput2("\nInput error: Please enter a valid number (2 or 3)\n")
								promptFor2or3Input() // Re-prompt on invalid input
								return
							}
							if val == 2 || val == 3 { // Valid input
								radical_index = val
								fmt.Printf("\nin else if or, val is:%d, radical_index: %d\n", val, radical_index)
								fmt.Printf("Input: %d\n", val)

								// Proceed with calculation
								go func(done chan bool) {
									defer func() {
										calculating = false
										workPiece = 0
										updateOutput2("Calculation definitely finished; possibly aborted\n")
									}()
									// ::: this will become my roots solver app 
									xRootOfy(updateOutput2, radical_index, done)
									calculating = false
									for _, btn := range buttons2 {
										btn.Enable()
									}
								}(currentDone)
							} else { // Input is a number but not 2 or 3
								updateOutput2(fmt.Sprintf("\nInvalid input: %d. Please enter 2 or 3\n", val))
								promptFor2or3Input() // Re-prompt
							}
						} else { // Dialog canceled
							updateOutput2("Roots canceled, make another selection")
							for _, btn := range buttons2 {
								btn.Enable()
							}
							calculating = false
						}
					},
				)
			}
			// Below, we start the input prompt. Because, we've yet to actually call for anything to happen. If you had thought that "showCustomEntryDialog2(..." was a call to action you are mislead... 
			// ... All that was was part of an inline/literal func definition. The definition of a func called promptFor2or3Input. 
			promptFor2or3Input() // Execute the aforementioned and previously defined/resolvable func. If and only If we ever specifically direct that the game should begin. 
		},
	)
	/*
		.
		.
	*/
	// ::: Bailey chan -- will go here
					BBPfast44Btn2 := NewColoredButton(
						"BBP, the Bailey–Borwein–Plouffe formula for π, circa 1995\n" +
							"FAST -- only runs 4s to produce 10,000 digits of Pi" +
							"uses channels: GOMAXPROCS(numCPU), and using Go's big floats\n" +
							"                     --- done here by Rick Woolley ---          ",
						color.RGBA{25, 200, 100, 215},
						func() {
							var BppDigits int
							if calculating {
								return
							}
							calculating = true
							for _, btn := range buttons2 {
								btn.Disable()
							}
							for _, btn := range BPPbut2 { // Refer to the comments in the initial assignment and creation of archimedesBtn1
								calculating = true
								btn.Enable()
							}
							updateOutput2("\nRunning BBP-fast-190 up to here...\n\n")
				
							showCustomEntryDialog2(
								"Input Desired number of digits",
								"Any number less than 190",
								func(input string) {
									if input != "" { // This if-else is part of the magic that allows us to dismiss a dialog and allow others to run after the dialog is canceled/dismissed.
										input = removeCommasAndPeriods(input) // allow user to enter a number with a comma
										val, err := strconv.Atoi(input)
										if err != nil {
											fmt.Println("Error converting input:", err)
											updateOutput2("Invalid input, using default 190 digits")
										} else if val <= 0 {
											updateOutput2("Input must be positive, using default 190 digits")
										} else if val > 10000 {
											updateOutput2("Input must be less than 191 -- using default of 190 digits")
										} else {
											BppDigits = val
										}
										go func() {
											bbpFast44(updateOutput2, BppDigits, done) // ::: func < - - - - - - - - - - - - - < -  NOT AMENABLE TO KILLING VIA A DONE CHANNEL 
											calculating = false
											for _, btn := range buttons2 {
												btn.Enable()
											}
										}()
									} else {
										// dialog canceled 
										updateOutput2("spigot calculation canceled, make another selection")
										for _, btn := range buttons2 {
											btn.Enable()
										}
										calculating = false // ::: this is the trick to allow others to run after the dialog is canceled/dismissed.
									}
								},
							)
						})
	/*
	.
	.
	 */
	
	// ::: nila 3 goes here ??
	NilakanthaBtn2 := NewColoredButton(
		"Nilakantha -- input iterations\n" +
		"output up to 26 digits of pi",
		color.RGBA{255, 255, 100, 235},
	func() {
		if calculating {
			return
		}
		calculating = true
		for _, btn := range buttons2 {
			btn.Disable()
		}
		for _, btn := range nilaBut2 { // Refer to the comments in the initial assignment and creation of archimedesBtn1
			calculating = true
			btn.Enable()
		}
		getDualInput2("Input Required", "Number of iterations (suggest 300,000 -> 30,000,000  -> 300,000,000):", "Precision (suggest 128):", 
			"30000000", "128", // 30,000,000
			func(itersStr, precStr string, ok bool) {
				calculating = true
				for _, btn := range buttons2 {
					btn.Disable()
				}
				if !ok {
					updateOutput2("Nilakantha calculation canceled")
					return
				}
				iters := 30000000 // 30,000,000
				precision := 128
				itersStr = removeCommasAndPeriods(itersStr) // ::: allow user to enter a number with a comma
				val1, err1 := strconv.Atoi(itersStr)
				if err1 != nil {
					fmt.Println("Error converting iterations val1:", err1) // handle error
					iters = 30000000
				} else {
					iters = val1
				}
				val2, err2 := strconv.Atoi(precStr)
				if err2 != nil {
					fmt.Println("Error converting precision val2:", err2) // handle error 
					updateOutput2("setting precision to 128") 
					// fyneFunc(fmt.Sprintf("setting precision to 512")) //  ::: cannot do this instead because ??
					precision = 128
				} else {
					precision = val2
				}
				go NilakanthaBig(updateOutput2, iters, precision, done) // ::: probably want to add a done channel to this one
				calculating = false
				for _, btn := range buttons2 {
					btn.Enable()
				}
			})
	})

	// ::: temp, Bailey concur goes here
						ChudnovskyBtn2 := NewColoredButton("chudnovsky -- takes input", color.RGBA{255, 255, 100, 235},
						func() {
							if calculating {
								return
							}
							calculating = true
							for _, btn := range buttons2 {
								btn.Disable()
							}
							for _, btn := range chudBut2 { // Refer to the comments in the initial assignment and creation of archimedesBtn1
								calculating = true
								btn.Enable()
							}
							getSingleInput2("Input Required", "Enter the number of digits for the chudnovsky calculation (e.g., 46):", "46",
								func(digitsStr string, ok bool) {
									var chudDigits int 
									if !ok {
										updateOutput2("chudnovsky calculation canceled")
										return
									}
									chudDigits = 46
									val, err := strconv.Atoi(digitsStr)
									if err != nil {
										fmt.Println("Error converting input:", err) // handel error 
										updateOutput2("Invalid input, using default 46 digits")
									} else if val <= 0 {
										updateOutput2("Input must be positive, using default 46 digits")
									} else if val > 10000 {
										updateOutput2("Input must be less than 10,001, using default 46 digits")
									} else {
										chudDigits = val
									}
									go func() {
										chudnovskyBig(updateOutput2, chudDigits, done)
										calculating = false
										for _, btn := range buttons2 {
											btn.Enable()
										}
									}()
								})
						})

	/*
		.
		.
	*/

	rootBut2 = []*ColoredButton{RootsBtn2}
	BPPbut2 = []*ColoredButton{BBPfast44Btn2}
	chudBut2 = []*ColoredButton{ChudnovskyBtn2}
	nilaBut2 = []*ColoredButton{NilakanthaBtn2}

	buttons2 = []*ColoredButton{RootsBtn2, NilakanthaBtn2, ChudnovskyBtn2} // array used only for range btn.Enable()

	// ::: page-2 Lay-out
		content2 := container.NewVBox(
			widget.NewLabel("\nSelect a method to estimate π:\n"),
			container.NewGridWithColumns(4, RootsBtn2, NilakanthaBtn2, ChudnovskyBtn2),
			coloredScroll2, // Use coloredScroll2 directly or windowContent2 if you want an extra layer
		)
		windowContent2 := container.NewMax(bgwc2, content2) // Light green window bg // containers withing containers, labels on labels, functions in functions. Yet still inert. 
	

/*
   	window2.Canvas().SetOnTypedRune(func(r rune) { // Main-thread update loop using Fyne's lifecycle -- here an empty loop ::: see below:
   	})

   Every Fyne window has a Canvas, which is the drawable surface where all widgets (buttons, labels, etc.) are rendered. Calling window2.Canvas() gives you access to this canvas, 
letting you interact with its properties or events.

   .SetOnTypedRune(func(r rune) { ... }):
   This method sets a callback function that Fyne calls whenever a user types a character (a "rune") into the window, provided the window has focus.

   A rune in Go is an alias for int32 and represents a Unicode code point—essentially a single character, like 'a', '5', or 'π'. It’s more general than a byte, allowing it to handle 
all kinds of text input (e.g., emojis, non-Latin scripts).

   func(r rune) { ... }:
   This is the callback function you provide. It runs on the main thread whenever a key is typed, and it receives the typed character (r) as an argument. The body of this 
function (which you’ve shown as empty {}) is where you’d define what happens when a key is pressed.

   "Main-thread update loop using Fyne's lifecycle":
   The comment suggests this is part of Fyne’s event-driven lifecycle. Fyne runs its GUI in a single-threaded, event-based model on the main thread. When you set this callback, it 
hooks into that lifecycle, ensuring your response to keypresses happens synchronously with other GUI updates (like rendering or widget changes). This avoids concurrency issues that 
could arise if you tried to update the GUI from another thread.
:::
   In short, window2.Canvas().SetOnTypedRune(func(r rune) { ... }) lets you capture and respond to keyboard input in window2. For example:
   If a user types 'q', the function runs with r = 'q'.

   You could use this to close the window, update a label, or trigger a calculation based on the input.

:::    Since your example has an empty function body ({}), it currently does nothing—it’s just a placeholder. The real action depends on what you put inside the {}.


*/

		window2.SetContent(windowContent2) // Set once with the full layout
	return window2
} // end of createWindow2 "it's only a label". "no Show, no go" 


// ::: ------------------------------------------------------------------------------------------------------------------------------------------------------------
func createWindow3(myApp fyne.App) fyne.Window {
	// Similar structure to createWindow2
	window3 := myApp.NewWindow("Odd Pi calculators")
	window3.Resize(fyne.NewSize(1900, 1600))
	outputLabel3 := widget.NewLabel("Odd Pi calculators, make a selection")
	outputLabel3.Wrapping = fyne.TextWrapWord
	scrollContainer3 := container.NewScroll(outputLabel3)
	scrollContainer3.SetMinSize(fyne.NewSize(1900, 1300))
	buttonContainer3 := container.NewGridWithColumns(4,
		widget.NewButton("Button 9", func() {}),
		widget.NewButton("Button 10", func() {}),
		widget.NewButton("Button 11", func() {}),
		widget.NewButton("Button 12", func() {}),
		widget.NewButton("Button 13", func() {}),
		widget.NewButton("Button 14", func() {}),
		widget.NewButton("Button 15", func() {}),
		widget.NewButton("Button 16", func() {}),
	)
	content3 := container.NewVBox(buttonContainer3, scrollContainer3)
	window3.SetContent(content3)
	return window3
}

// ::: ------------------------------------------------------------------------------------------------------------------------------------------------------------
func createWindow4(myApp fyne.App) fyne.Window {
	// Similar structure to createWindow2
	window4 := myApp.NewWindow("Misc Maths")
	window4.Resize(fyne.NewSize(1900, 1600))
	outputLabel4 := widget.NewLabel("Misc Maths, make a selection")
	outputLabel4.Wrapping = fyne.TextWrapWord
	scrollContainer4 := container.NewScroll(outputLabel4)
	scrollContainer4.SetMinSize(fyne.NewSize(1900, 1300))
	buttonContainer4 := container.NewGridWithColumns(4,
		widget.NewButton("Button 17", func() {}), widget.NewButton("Button 18", func() {}), widget.NewButton("Button 19", func() {}), widget.NewButton("Button 20", func() {}),
		widget.NewButton("Button 21", func() {}), widget.NewButton("Button 22", func() {}), widget.NewButton("Button 23", func() {}), widget.NewButton("Button 24", func() {}),
	)
	content4 := container.NewVBox(buttonContainer4, scrollContainer4)
	window4.SetContent(content4)
	return window4
}
